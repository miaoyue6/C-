## 编程基础

#### 1.变量声明和定义区别？

*声明仅仅是吧变量声明的位置及类型提供给编译器，并不分配内存空间，定义要在定义的地方为其分配存储空间；

*相同的遍历可以在多处声明，（外部变量extern，在其他文件中声明本文件），但只能在一处定义；

#### 2.“零值比较”？



- bool类型：if(flag)
- int类型：if(flag == 0)
- 指针类型：if(flag == null)
- float类型：if((flag >= -0.000001) && (flag <= 0. 000001))

float 类型不能比较相等或不等，但可以比较>,<,>=,<=

用==从语法上说没错，但是本来应该相等的两个浮点数由于计算机内部表示的原因可能略有微小的误差，这时用==就会认为它们不等。应该使用两个浮点数之间的差异的绝对值小于某个可以接受的值来判断判断它们是否相等,比如用

  if (fabs(price - p) < 0.000001)

来代替

  if (price == p)

#### 3.strlen和sizeof区别？

*sizeof是运算符，并不是函数，结果在编译时得到而不是在运行中获得；strlen是字符处理函数；

*sizeof参数可以使任何类型数据；strlen的参数只能是字符指针，且结尾是"\0";

*因为sizeof是在编译时确定，所以不能用来得到动态分配存储空间的大小；

#### 4.同一不同对象可以相互赋值吗？

*含有指针成员时需要注意；

*对比类的对象赋值时深拷贝、浅拷贝；

``` c++
//同一类的对象进行赋值时，如果类中用*p指向new的一块内存，那么A=B时，A中的*p指向地址和B中*P指向的地址是同一块地址，然后其他的成员变量进行浅拷贝赋值；
参考：https://blog.csdn.net/u012273127/article/details/52015787
如例子1：
    class CImgData
{
public:
int *pimgdata = new int [10];
int width;
int height;
};
        主函数：
int main()
{
CImgData A;
A.width = 2;
A.height = 3;
for (int i = 0; i < 10; i++)
{
A.pimgdata[i] = i * 7 + 5;
}
cout << "A 的地址是： " << endl;
cout << A.pimgdata << endl;
 
CImgData B;
//ACImgDataToBCImgData(A, B);
B = A;
cout << "B 的地址是： " << endl;
cout << B.pimgdata << endl;
 
 
for (int m = 0; m < 10; m++)
cout << B.pimgdata[m] << endl;
 
cout << "B.width= " << B.width << endl;
cout << "B.height=" << B.height << endl;
 
cout << "completed" << endl;
}
```

``` c++
//然后，注意了！注意了！坑来了
//下面代码，把对象作为形参传递，然后函数中的A和B相当于临时对象tempA和tempB，那么在函数中进行赋值时，实际上改变的是临时变量的成员变量，但是由于tmpA=A时，指向的是同一块内存，所以指向同一块内存的对象中的数据传递过去了，而其他的仅仅是在临时对象tmpA和tmpB中进行传递，A和B啥都没得到，仅仅有内存那部分数据改变；
 void ACImgDataToBCImgData(CImgData  A, CImgData  B)
{
B.height = A.height;
B.width = A.width;
for (int i = 0; i < 10; i++)
{
B.pimgdata[i] = A.pimgdata[i];
}
}
       主函数：
      int main()
       {
CImgData A;
A.width = 2;
A.height = 3;
for (int i = 0; i < 10; i++)
{
A.pimgdata[i] = i * 7 + 5;
}
cout << "A 的地址是： " << endl;
cout << A.pimgdata << endl;
 
CImgData B;
ACImgDataToBCImgData(A, B);
 
cout << "B 的地址是： " << endl;
cout << B.pimgdata << endl;
 
for (int m = 0; m < 10; m++)
cout << B.pimgdata[m] << endl;
 
 
cout << "B.width= " << B.width << endl;
cout << "B.height=" << B.height << endl;
 
 
cout << "completed" << endl；
return 0;
}
```

那么怎么解决上述问题呢，引用&就解决了

``` c++
 void ACImgDataToBCImgData(CImgData  A, CImgData  B)
{
B.height = A.height;
B.width = A.width;
for (int i = 0; i < 10; i++)
{
B.pimgdata[i] = A.pimgdata[i];
}
}
       主函数：
      int main()
       {
CImgData A;
A.width = 2;
A.height = 3;
for (int i = 0; i < 10; i++)
{
A.pimgdata[i] = i * 7 + 5;
}
cout << "A 的地址是： " << endl;
cout << A.pimgdata << endl;
 
CImgData B;
ACImgDataToBCImgData(A, B);
 
cout << "B 的地址是： " << endl;
cout << B.pimgdata << endl;
 
for (int m = 0; m < 10; m++)
cout << B.pimgdata[m] << endl;
 
 
cout << "B.width= " << B.width << endl;
cout << "B.height=" << B.height << endl;
 
 
cout << "completed" << endl；
return 0;
}
```

#### 5.结构体内存对齐问题

*结构体内按成员变量顺序存储，第一个成员变量和整个结构体地址相同；

*未特殊说明时，按结构体中size最大的成员对齐

``` c++
参考：https://blog.csdn.net/G_METHOD/article/details/79535178
//为甚要结构体内存对齐
因为CPU每次从内存中取出内存按照## CPU能够一次性处理的数据长度取出，比如32位处理器一次性取出4个字节
//然后参考自然对齐和规则对齐
    
```

![image-20200715164004098](C:\Users\miao\AppData\Roaming\Typora\typora-user-images\image-20200715164004098.png)

#### 6.static作用是什么？在C和C++中区别？

*static可以修饰局部变量（静态局部变量）、全局变量（静态全局变量）和函数，被修饰的变量存储位置在静态区。

对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义；

对于静态全局变量，相对于一般全局变量，其可见范围仅限本文件；

修饰函数时和修饰全局变量时相同，都是为了限制访问域；

*static还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例共有；

*static的数据记忆性可以满足函数在不同调用期间的调用，也可以满足同一个类的多个实例之间的通信；

*未初始化时，static变量默认是0；

*static与const不同，因为static改变的一般是变量或者函数的作用域；而const改变的是他这个变量中的值是否还能变化

#### 7.结构体和类的区别？

*结构体和类的唯一区别就是：结构体和类具有不同的默认访问属性。

​	类中，对于未指定访问控制属性的成员，其访问属性为私有类型（private）；

​	结构体中，对于未指定的任何访问控制属性的成员，其访问类型为共有类型（public）。

*作用：用结构体封装一些属性来组成新的类型，目的是简化运算。

#### 8.malloc和new区别？

new用法：

​			(1)	int *pi=new int(1024);分配一个Int型区域，初始值为1024

​				delete pi;

​			(2)	int *pi=new int[];

​					delete [] pi;

malloc用法：

``` c++
void *malloc(size_t size);
void free(void *pointer);
```



​			malloc（）函数的返回值类型为void*,所以需要在函数前面进行相应的强制类型转换。

​			(1)int *p=(int *)malloc(100)，指向100字节的内存地址

​			(2)free(p)；

*区别：

a、属性：new/delete是C++关键字，需要编译器支持；malloc/free是库函数，需要头文件支持。

b、参数：使用new操作符申请内存分配时无需指定内存块的大小，编译器会根据类型信息自行计算。而malloc需要显示的指出所需内存的尺寸。

c、返回类型：

​	new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无需进行强制类型转换，故new是符合类型安全性的操作符。

​	而malloc内存分配成功返回的是void*，需要进行强制类型转换将void*指针转换为我们需要的类型。

d、内存区域

​	new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。

**自由存储区不等于堆**，如上所述，布局new就可以不位于堆中。

- **自由存储是C++中通过new与delete动态分配和释放对象的抽象概念，而堆（heap）是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。**
- **new所申请的内存区域在C++中称为自由存储区。藉由堆实现的自由存储，可以说new所申请的内存区域在堆上。**
- **堆与自由存储区还是有区别的，它们并非等价。**

**内存管理（操作系统概念）：**

***栈区**：由编译器自动分配释放，存储函数的参数值，局部变量等，其操作方法类似于数据结构中的栈；

----------const修饰存储在栈区，只是把变量变为只读。

***堆区**：一般由程序员申请和释放，与数据结构中的堆没有关系，分配方式类十余链表。malloc

***全局/静态区**：全局变量和静态变量存储在一起(关于作用域的)

***文字常量区**：存储常量字符串(关于是否是字符串常量的)

***程序代码区**：存储函数体（类的成员函数、全局函数）的二进制代码

#### 9.指针和引用的区别？

***引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间；**

*引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。

*引用一旦初始化后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针可以重新指向别的变量；

*不存在指向空值的引用，必须有具体实体；但存在指向空值的指针；

#### 10.宏定义和函数的区别

``` c++
#define SQUARE(x) ((x)*(x))
int main()
{
    int input;
    printf("Please input:");
    scanf("%d", &input);
    printf("%d\n", SQUARE(input));
    system("pause");
    return 0;
}
```



***宏在编译时完成替换**，之后被替换的文本参与编译，相当于直接插入代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数；

*宏函数属于在结构中插入代码，**没有返回值**；函数具有返回值；

*宏函数**参数没有类型**，不进行类型检查；函数参数具有类型，需要检查类型；

*宏函数不要在最后加分号

#### 11.宏定义和const区别？

**类型和安全检查不同**

宏定义是字符替换，没有数据类型区别，同时这种替换没有类型安全检查，可能产生边际效应等错误；

**编译器处理不同**

宏定义是一个“编译时”概念，在预处理阶段展开，不能对宏定义进行调试生命周期结束于编译时期；

const是一个“运行时”概念，在程序中使用，类似一个只读数据；

**存储方式不同**

宏定义是直接替换，不会分配内存，存储于程序的代码段中；

const常量需要进行内存分配，存储于程序的数据段中；

#### 12.宏定义和typedef区别？

***目的不同* **：宏主要用于定义常量以及书写复杂的内容；typdef主要用于定义类型别名；

**编译时间 **：宏替换发生在编译之前，属于文本插入替换；typdef是编译的一部分；

**安全** ：宏不检查类型；typdef会检查数据类型；

**语句？** ：宏不是语句，不在最后加分号；typdef是语句，在句末加分号；

**指针操作**：注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大

**const char* p /char const *p ** :const 修饰*p，表示p所指内容 不变；

**char* const p** :p不能改变，表示指针p不变，就指向那一块；

``` c++
//记住，typedef是定义了一种类型的新别名，不同于宏，它不是简单的字符串替换。比如：

　　先定义：

　　typedef char* PSTR;

　　然后：

　　int mystrcmp(const PSTR, const PSTR);

　　const PSTR实际上相当于const char*吗？不是的，它实际上相当于char* const。

　　原因在于const给予了整个指针本身以常量性，也就是形成了常量指针char* const。

　　简单来说，记住当const和typedef一起出现时，typedef不会是简单的字符串替换就行。
```

``` c++
//表明typdef是一个类型明，并不是简单的替换
同样给一个 指针起别名
#define DEFPCHAR char*
typedef char* TPYEPCHAR;
如果bai DEFPCHAR a, b;
那么是直接展开宏为 char* a, b;这里 只有a背定义成du了指针而b成了char!!!!
如果是TPYEPCHAR a, b;他们都是指针了
```

#### 13.宏定义和内联函数区别？

*在使用时，宏只做简单的字符串替换（编译前）。而内联函数可以进行参数检测（编译时），且具有返回值。

*内联函数本身就是函数，强调函数特性，具有重载功能。

*内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类的保护成员或私有成员时，宏就不能实现了。

#### 14.条件编译\#ifdef, #else, #endif作用？

- 可以通过加#define，并通过#ifdef来判断，将某些具体模块包括进要编译的内容。
- 用于子程序前加#define DEBUG用于程序调试。
- 应对硬件的设置（机器类型等）。
- 条件编译功能if也可实现，但条件编译可以减少被编译语句，从而减少目标程序大小。



#### 15.区别以下几种变量？

``` c++
const int a;
int const a;
const int *a;
int* const a;
```

*int const a和const int a均表示定义常量类型a；

- const int *a，其中a为指向int型变量的指针，const在 * 左侧，表示a指向不可变常量。(看成const (*a)，对引用加const)
- int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)

#### 16.volatile有什么作用？

**volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。保证对特殊地址的稳定访问**

``` c++
//volatile定义的变量的值是易变得，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。

//多线程中被几个任务共享的变量需要定义为volatile类型。
```

#### 17.什么是常引用？

 * 常引用可以理解为常量指针，形式为const typename & refname= varname;const int & a=b;

 * 常引用下，原变量值不会被别名所修改；

   ``` c++
   const int &a=10;
   		  a=12;//编译错误
   ```

   * 原变量的值可以通过原名修改；
   * **常引用通常用作只读变量别名或者形参传递。**

#### 18.区别以下指针类型？

``` c++
int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)
```

*int *p[10]表示指针数组，强调数组概念，数组内每个元素都是指向int型的指针变量；*

-int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组的大小是10；

-int**p(int)是函数声明，函数名是p，参数是int类型的，返回值是Int*类型的；

int(*p)(int)是函数指针，强调的是指针，该指针指向的函数具有int类型，并且返回的值是int类型的。

#### 19.常量指针和指针常量的区别？（前边的都不变，强调后边）

	* 常量指针是一个指针，指向的值不能改变是一个常量，比如const int *p 或者 int const *p;
	* 指针常量指的是一个不能改变的指针，如int * const p。

#### 20.a和&a有什么区别？

``` c++
//假设数组int a[10]；
int (*p)[10]=&a;
```

	* a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1后变为0x00000005.*（a+1)=a[1];
	* &a是数组的指针，其类型为int(*p)[10],**指的是整个数组** ，其加1时，系统会认为数组首地址加上整个数组的偏移（10个int型变量)，值为数组a尾元素后一个元素的地址；
	* ???//若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。

#### 21.数组名和指针区别？

-二者均可以通过增减偏移量来访问数组中的元素；

-数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作；

-当数组名当做形参传递给调用函数后，就失去原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了；

#### 22.野指针

``` c++
(1)指针没有初始化。任何指针刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建初期的同时应当被初始化，要么将指针设置为NULL，要么让他指向合法的内存。
    char *p;
(2)指针p被free或者delete之后，没有置为NULL，让人误以为p是一个合法的指针
    char *p=new char[10];  //指向堆中分配的内存首地址，p存储在栈区
	cin>> p;
	delete []p; //p重新变为野指针
(3)指针的操作超越了变量的作用范围
    char *p=new char[10]; //指向堆中分配的内存首地址
	cin>> p;
	cout<<*(p+10); //可能输出未知数据
```

-也叫作空悬指针，不是指向null的指针，是指向垃圾内存的指针；

-产生原因及解决办法：

	* 指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。
* 指针free或delete之后没有及时置空 => 释放操作后立即置空。

#### 23.堆和栈的区别？

**申请方式不同**

	* 栈由系统自动分配
	* 堆由程序员手动分配

**申请大小限制不同**（栈之前设定好了，但是堆大小可以调整）

	* 栈顶和栈底是之前预设好的，大小固定，可以通过ulimit -a查看，由ulimit -s修改。
* 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。

**申请效率不同**

	* 栈由系统分配，速度快，不会有碎片。
* 堆由程序员分配，速度慢，且会有碎片。

#### 24.delete和delete[]区别？

- delete只会调用一次析构函数。
- delete[]会调用数组中每个元素的析构函数。

# 面向对象基础

#### 1.面向对象三大特性？

**封装性** ：数据和代码捆绑在一起，避免外界干扰和不确定性访问；

**继承性** ：让某种类型对象获得另外一种类型对象的属性和方法；

**多态性** ：同一事务表现出不同事务的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为(重载实现编译时多态，虚函数实现运行时多态)。

#### 2.public/protected/private的区别？

- public的变量和函数在类的内部外部都可以访问。
- protected的变量和函数只能在类的内部和其派生类中访问。
- private修饰的元素只能在类内访问。

#### 3.对象存储空间？

 * 非静态成员的数据类型大小之和；

 * 编译器加入的额外成员变量（如指向虚函数表的指针）；

 * 为了边缘对齐优化加入的padding

   

   

    

   **对象里存储着虚表指针和成员变量。一个数组，最上面是虚表指针，第二是基类成员变量，第三是子类成员变量***

**成员函数和静态成员变量不占用对象的存储空间。**

​																		

| 对象内存布局                                 |
| -------------------------------------------- |
| 虚函数表指针（指向虚函数表）*4字节或者8字节* |
| 基类成员变量                                 |
| 子类成员变量                                 |

 

![image-20200721153639408](C:\Users\miao\AppData\Roaming\Typora\typora-user-images\image-20200721153639408.png)

``` c++
//对象内存大小：static成员变量、虚函数、继承、内存补齐；
//内存计算规则：对象内存大小为成员变量之和，成员函数不占内存，但虚函数指针占内存，无成员变量的对象大小为1字节。
考虑成员变量内存对齐规则：
     1、成员变量的偏移量必须为该变量自身大小的整数倍；（也就是每加上一个字节，这个字节都在自己的大小的整倍数上）
	2、对象内存的大小为最大成员变量大小的整数倍；

```

#### 4.C++空类有哪些成员函数？

*首先空类大小为1字节；

*默认构造函数：

	* 构造函数
	* 析构函数
	* 拷贝构造函数
	* 赋值运算符

https://www.bilibili.com/video/BV1mx411Z7fx?p=7

**深拷贝**：对象A赋值给B，B会重新创建新的内存，复制后有两个内存块

浅拷贝：对象A赋值给B，B会复制A的指针，复制后有一个个内存块，且A和B都指向这个内存块，但此时B原来的内存块丢失，造成内存泄漏

**操作符重载**：

![image-20200721165318066](C:\Users\miao\AppData\Roaming\Typora\typora-user-images\image-20200721165318066.png)



``` c++
 //每个成员函数隐含带有this
//+=操作符作用在C2上
```









