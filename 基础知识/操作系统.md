# 操作系统

## 进程和线程

``` c
//线程和进程的概念已经在操作系统书中被翻来覆去讲了很多遍。很多概念虽然都是套话，但没能理解透其中深意会导致很多内容理解不清晰。对于进程和线程的理解和把握可以说基本奠定了对系统的认知和把控能力。其核心意义绝不仅仅是“线程是调度的基本单位，进程是资源分配的基本单位”这么简单。
```

#### 多线程

同一进程内部有多个线程，所有的线程共享一个进程的内存空间，进程中定义全局变量会被所有的线程共享。

``` c
//但是，虽然线程在安全性方面会引入许多新挑战，但是线程带来的好处也是有目共睹的。首先，原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。比如QQ可以一个线程处理聊天一个线程处理上传文件，两个线程互不干涉，在用户看来是同步在执行两个任务，试想如果线性完成这个任务的话，在数据传输完成之前用户聊天被一直阻塞会是多么尴尬的情况。
```

- 线程之间有无先后访问顺序（线程依赖关系）
- 多个线程共享访问同一变量（同步互斥问题）

#### 多进程

父进程创建子进程，子进程拷贝父进程相关数据，但并不是说他们对同一块数据进行操作，子进程会在拷贝的数据上进行操作。

##### 1.进程创建于结束

pid_t fork(void);

exit()

##### 2.僵尸进程、孤儿进程

父进程在调用fork接口之后和子进程已经可以独立开，之后父进程和子进程就以未知的顺序向下执行（异步过程）。所以父进程和子进程都有可能先执行完。当父进程先结束，子进程此时就会变成孤儿进程，不过这种情况问题不大，孤儿进程会自动向上被init进程收养，init进程完成对状态收集工作。而且这种过继的方式也是守护进程能够实现的因素。如果子进程先结束，父进程并未调用wait或者waitpid获取进程状态信息，那么子进程描述符就会一直保存在系统中，这种进程称为僵尸进程。

相关接口：

- 回收进程（1）：pid_t wait(int *status);

  一旦调用wait()，就会立即阻塞自己，wait()自动分析某个子进程是否已经退出，如果找到僵尸进程就会负责收集和销毁，如果没有找到就一直阻塞在这里。

  - status：指向子进程结束状态值。

- 回收进程（2）：pid_t waitpid(pid_t pid, int *status, int options);

  返回值：返回pid：返回收集的子进程id。返回-1：出错。返回0：没有被手机的子进程。

  - pid：子进程识别码，控制等待哪些子进程。
    1. pid < -1，等待进程组识别码为pid绝对值的任何进程。
    2. pid = -1，等待任何子进程。
    3. pid = 0，等待进程组识别码与目前进程相同的任何子进程。
    4. pid > 0，等待任何子进程识别码为pid的子进程。
  - status：指向返回码的指针。
  - options：选项决定父进程调用waitpid后的状态。
    1. options = WNOHANG，即使没有子进程退出也会立即返回。
    2. options = WUNYRACED，子进程进入暂停马上返回，但结束状态不予理会。



#### 3.守护进程

守护进程是一直运行的服务端程序，又称为守护进程。通常在系统后台运行，没有控制终端，不予前台交互。

- 背景知识：

  守护进程是脱离终端并在后台运行的进程，执行过程中信息不会显示在终端上并且也不会被终端发出的信号打断。

- 操作步骤：

  - 创建子进程，父进程退出：fork() + if(pid > 0){exit(0);}，使子进程称为孤儿进程被init进程收养。
  - 在子进程中创建新会话：setsid()。
  - 改变当前目录结构为根：chdir("/")。
  - 重设文件掩码：umask(0)。
  - 关闭文件描述符：for(int i = 0; i < 65535; ++i){close(i);}

> ``` c++
> 僵尸进程Q：介绍一下僵尸进程吧A：僵尸进程就是死掉之后还没有被父进程wait的进程，它们在运行结束之后PCB这些资源还没有被释放，等待父进程wait它们获得它们的状态。如果父进程不wait的话，僵尸进程多了，未被释放的资源就很多，这个时候系统性能就会受到影响。
>     //如果父进程早死了的话，子进程就会被托管到pid为1的进程，以前是init现在是systemd好像，它会定时wait掉所有死了的子进程Q：
>     怎样避免僵尸进程呢A：单独一个线程wait子进程，或者emmm...有两个信号，一个SIGCHLD、一个SIGCLD，设置这两个信号的处理方式为忽略，它们告诉内核，不关心子进程结束的状态所以当子进程终止的时候直接释放所有资源就行。它们的区别是SIGCLD在安装完信号处理函数的时候还会检查是否已经存在结束的子进程，如果有就调用信号处理函数，而SIGCHLD不会，也就是可能会丢掉已经有子进程已经结束这个事实
> 
> 作者：小兔子奈奈啊
> 链接：https://zhuanlan.zhihu.com/p/80314833
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
> ```
>

#### 同步异步IO

- 上面三种I/O方式均属于同步I/O。
- 从阻塞式I/O到非阻塞I/O，我们已经做到了调用I/O请求后立即返回，但不停轮询的操作效率又很低，如果能够既像非阻塞I/O能够立即返回又能不一直轮询的话会更符合我们的预期。
- 之所以用户进程会不停轮询就是因为在数据准备完毕后内核不会回调用户进程，只能通过用户进程一次又一次轮询来查询I/O结果。如果内核能够在完成I/O后通过消息告知用户进程来处理已经得到的数据自然是最好的，异步I/O就是这么回事。
- 异步I/O就是当用户进程发起I/O请求后立即返回，直到内核发送一个信号，告知进程I/O已完成，在整个过程中，都没有进程被阻塞。看上去异步I/O和非阻塞I/O的区别在于：判断数据是否准备完毕的任务从用户进程本身被委托给内核来完成。这里所谓的异步只是操作系统提供的一直机制罢了。

``` c++
同步IO是指用户不停轮询查询IO结果；
异步IO是指内核在完成IO后通过消息告知用户进程来处理数据
```





