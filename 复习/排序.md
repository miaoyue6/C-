

# 排序

![image-20200820105859986](C:\Users\miao\AppData\Roaming\Typora\typora-user-images\image-20200820105859986.png)

#### 冒泡

``` c++
//冒泡排序
1.定义：比较相邻的元素。如果第一个比第二个大，就交换他们；
2.时间复杂度：最好O(n^2)；最坏：O(n^2)；平均：O(n^2)
3.稳定性：稳定
    for(int i=1,i<len;i++){
        for(int j=0;j<len-i;j++){
            if(arr[j]>arr[j+1])
                exchange(arr,j,j+1);
        }
    }

```

``` c++

//快速排序
1.定义：两个哨兵i、j进行移动判断，i在左边，j在右边；i找出比哨兵大的数，j找出比哨兵小的数，然后交换；
2.时间复杂度：O(nlogn)
3.不稳定
    //注意：先移动j哨兵，因为当i>j时表示停止，这时必须通过j找到比基准小的数然后与基准交换；
    //也就是说，快速排序就是找一个基准，然后把比基准小的数放在基准左边，比基准大的数放在基准右边，我们要保证最后一次是将小的数和基准交换，所以我们要先找到j对应的数；
    //重更：最后一次交换的时候，i是表示交换后复合要求比基准小的数，然后通过j来退出循环
    void quickSort(int left, int right, vector<int>& arr)
{
    if(left>=right)
        return;
    base=arr[left];
    while(i<j)
    {
        while(arr[j]>=base&&i<j)
            j--;
        while(arr[i]<=base&&i<j)
            i++;
        if(i<j)
        {
            temp=arr[i];
            arr[i]=arr[j];
            arr[j]=temp;
        }
    }
    arr[left]=arr[i];
    ar[i]=base;
    quickSort(left, i - 1, arr);//递归左边
	quickSort(i + 1, right, arr);//递归右边
}

```

#### 快速

#### 插入

``` c++
//插入排序
1.定义：就是认为当前前边的序列是有序的，然后一个一个插入，往后移动；
2.O(n^2)
3.稳定
	for(int i=1;i<len;i++){
        for(int j=i-1;j>=0&&arr[j]>arr[j+1];j--)
            exchange(arr,j,j+1);
    }
```

#### 希尔排序

``` c++
1.先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法流程：
选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
按增量序列个数k，对序列进行k 趟排序；
每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度
2.(插入排序;时间A:N^1.3 , B:N^2 , E:N;空间1;不稳定)
```

#### 选择排序

``` c++
//就是每一趟选一个最小的放在队首，然后继续选
1.定义：选择排序法 是对 定位比较交换法（也就是冒泡排序法） 的一种改进。

选择排序的基本思想是：每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。

简单选择排序的基本思想：第1趟，在待排序记录r[1]~r[n]中选出最小的记录，将它与r[1]交换；第2趟，在待排序记录r[2]~r[n]中选出最小的记录，将它与r[2]交换；以此类推，第i趟在待排序记录r[i]~r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。

以下为简单选择排序的存储状态，其中大括号内为无序区，大括号外为有序序列：
初始序列：{49 27 65 97 76 12 38}
　　第1趟：12与49交换：12{27 65 97 76 49 38}
　　第2趟：27不动　：12 27{65 97 76 49 38}
　　第3趟：65与38交换：12 27 38{97 76 49 65}
　　第4趟：97与49交换：12 27 38 49{76 97 65}
　　第5趟：76与65交换：12 27 38 49 65{97 76}
　　第6趟：97与76交换：12 27 38 49 65 76 97 完成
```

#### 堆排序

``` c++
//堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。
//时间复杂度：(选择排序;时间A:NlogN,B:NlogN,E:NlogN;空间1;不稳定)
```

#### 归并排序

``` c++
//分治
(插入排序;时间A:NlogN,B:NlogN,E:N*logN;空间N;稳定)
```

#### 计数排序

``` c++
//计数排序就是在一定范围内的整数排序，通过设置一个大于1的数组，然后遍历整数序列，得到每个数的个数；
//以max和min为标准，新建立一个数组，长度max-min+1；
(计数排序;时间A:N+k,B:N+k,E:N+k;空间N+k;稳定)
```

#### 桶排序

![image-20200820143725228](C:\Users\miao\AppData\Roaming\Typora\typora-user-images\image-20200820143725228.png)

``` c++
//桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。
桶排序(时间A:N+k,B:N^2,E:N+k;空间N+k;稳定)
```

#### 基数排序

``` c++
//基数排序能够处理复杂字符串的排序
//按照关键字排序
将字符串按照元素拆分，每一位进行一次计数排序的过程
    (基数排序;时间A:N * k , B:N * k , E:N * k ; 空间N+k ; 稳定)
```

![image-20200820145054323](C:\Users\miao\AppData\Roaming\Typora\typora-user-images\image-20200820145054323.png)

