# 计网

## chapter 1

## 传输层（TCP/UDP）

#### 1.ISO七层模型中表示层和会话层功能是什么？

*表示层：图像、视频编码解，数据加密

> ``` c++
> 转换和翻译
> //表示层提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层数据能被另一个系统的应用层识别。如果有必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换为通信中标准的表示形式。数据压缩和加密也是表示层可提供的转换功能之一
> Eg: 由于公司A和公司B是不同国家的公司，他们之间的商定统一用英语作为交流的语言，所以此时表示层（公司的文秘），就是将应用层的传递信息转翻译成英语。同时为了防止别的公司看到，公司A的人也会对这份报价单做一些加密的处理。这就是表示的作用，将应用层的数据转换翻译等
> 
> ```

**会话层：建立会话，如senssion认证、断点续传。

> ``` c++
> //会话层就是负责建立、管理和终止表示层实体之间的通信。该层的通信由不同设备中的应用层序之间的服务请求和相应组成。
> Eg: 会话层的同事拿到表示层的同事转换后资料，（会话层的同事类似公司的外联部），会话层的同事那里可能会掌握本公司与其他好多公司的联系方式，这里公司就是实际传递过程中的实体。他们要管理本公司与外界好多公司的联系会话。当接收到表示层的数据后，会话层将会建立并记录本次会话，他首先要找到公司B的地址信息，然后将整份资料放进信封，并写上地址和联系方式。准备将资料寄出。等到确定公司B接收到此份报价单后，此次会话就算结束了，外联部的同事就会终止此次会话。
> ```

#### 2.描述TCP头部？

![img](https://img-blog.csdn.net/20180501221501343?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE3NjExMjg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**序号**(32bit)：传输方向上字节流编号。初始时序号会被设置为一个随机的初始值（ISN），之后每次发送数据时，序号值=ISN+数据在整个字节流中的偏移。

假设A->B且ISN=1024，第一段512字节数据已经到达B，则第二段数据发送时序号为1024+512。用于解决网络包乱序问题。

**确认号**：接收方对发送方TCP报文的响应，其值是期望收到的下一个序列号。

``` CQL
//第一次182发给208，发的长度是7，seq是1.所以208回复的ack是8。也相当于告诉182：“182，你下次发的时候，序号就从8开始”。看第2个红框，seq就是8.

//第二次208发给182，发的长度是11，seq是1，所以182回复的ack是12。也相当于告诉208：“208，你下次发的时候，序号就从12开始”。看第2个绿框，seq就是12.

同理，

182再发送一次给208，seq应该是17  

208再发送一次给182，seq应该是33
```



**首部长***：标识首部有多少个4字节首部长，最大为15，即60字节。

***标志位**：

​	**-** URG：标志紧急指针是否有效

​	**-** ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。

​	**-** PSH：提示接收端立即从缓冲读走数据。

​	**-** RST:表示对方重新建立连接(复位保温段)

​	**-** SYN：表示请求建立一个链接

​	**-** FIN：表示关闭连接(断开关闭连接)

**窗口** ：接收窗口，用于告诉对方本方的缓冲还能接收多少字节数据，用于解决流控。

**校验和** ：接收端用CRC检验整个保温段有无损坏。

#### 3.三次握手过程？

​	![image-20200716193440784](C:\Users\miao\AppData\Roaming\Typora\typora-user-images\image-20200716193440784.png)

第一次：客户端发送SYN位，seq=x；

第二次：服务器发送SYN，请求建立连接；ACK=1表示确认号有效，ack表示确认位，也就是下一次服务器想从客户端收到的序列号

第三次：客户端发送ACK=1，确认号有效，然后ack表示下一次想从服务器接收的序列号

#### 4.四次挥手过程

![image-20200716194558619](C:\Users\miao\AppData\Roaming\Typora\typora-user-images\image-20200716194558619.png)

**第一次** ：客户端发送含FIN位(停止位)，和seq序列号到服务器；

**第二次** ：服务器发送含ACK且，ack=u+1到客户端

* 此处有等待

**第三次** ：服务器发送含FIN到客户端

* 此处有等待

**第四次** ：客户端发送最后一个含有ACK的包到服务端

``` c++
//客户端不想发送数据时，那么就要告诉服务器，老子不发了，累了，于是给服务器发送FIN标志位，然后seq；
//服务器得知客户端不想发送数据后，得告诉客户端一声，于是发送给客户端我收到了ACK表示确认号有效，ack数值为u+1;

**这时服务器处于“关闭等待”状态，也就是服务器过一会再关闭**  
**这时客户端已经不再发送数据，处于“终止等待状态”** 
//过一会，服务器给客户端发送数据FIN，表示我也不再发送了
//然后客户端发送ACK，服务器收到后关闭，客户端等待一会关闭
```

#### 5.为什么握手三次？挥手四次？

* *对于握手：握手只需要确认双方通信时的初始化序号，保证通信不会乱序。*(第三次握手必要性：假设服务端的确认丢失，连接并未断开，)

  ``` c++
  **第一次握手: 客户端发送网络包，服务端收到了。
      //这样服务端可以得出结论，客户端的发送能力和服务端的接收能力是正常的；
  **第二次握手：服务端发送网络包，客户端收到了。
      //这样客户端得出结论，客户端的发送、接收能力正常，服务端的发送接收能力正常；
  **第三次握手：客户端发送数据，服务端收到了。
      //这样服务端得出结论，客户端的发送接收能力正常，服务端的发送接收能力正常，其实这次主要是确定服务端的发送能力
  ```

  

  ``` c++
  //试想如果是用两次握手，则会出现下面这种情况：
  
  如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。
  ```

  ​	

  * 四次挥手

    ``` c++
    //挥手为什么要四次？
    因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK。其中ACK报文是用来应答的，SYN是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭socket，所以只能先回答一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。
    ```

    ``` c++
    //2MSL等待状态
    TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。
    //四次挥手释放连接时，等待2MSL的意义?
    为了保证客户端发送的最后一个ACK报文能够到达服务器。因为这个ACK可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一旦这个ACK丢失的话，服务器就无法进入关闭连接状态。
    ```

    ![preview](https://picb.zhimg.com/v2-7c402fde8210519feb8f65d41410c205_r.jpg)

#### 6.TCP连接状态？

**CLOSED** :初始状态；

**LISTEN** ：服务器处于监听状态。

**SYN_SEND** :客户端socket执行CONNECT连接，发送SYN包，进入此状态。

**SYN_RECV** :服务端收到SYN包，进入此状态。

**ESTABLISH** :表示连接建立。客户端发送了最后一个ACK包进入此状态，服务端接收到ACK包进入此状态。

**FIN_WAIT_1** :终止连接的一方(通常是客户机)发送了FIN报文后进入；等待对方FIN。

**CLOSE_WAIT** :(假设服务器)收到客户端FIN包后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接(发送FIN包)取决于是否还有暑假需要发送给客户端，如有，则在发送FIN包之前均为此状态。

**FIN_WAIT_2** ：此时是半连接状态，即有一方要求关闭连接，等待一方关闭。客户端收到服务器的ACK包，但并没有立即收到服务器的FIN包，进入FIN_WAIT_2状态。

**LAST_ACK** ：服务器发的最后的FIN包，等待最后客户端ACK响应，进入此状态。

**TIME_WAIT** :客户端收到服务端的FIN包，立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。

#### 7.解释FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？

**FIN_WAIT_2** ：

	* 半关闭状态；
	* 发送断开请求一方还有接收数据能力，但已经没有发送数据能力；

**CLOSE_WAIT** :

	* 被动关闭连接一方收到FIN包会立即回应ACK包表示已经收到断开请求；
	* 被动关闭连接一方如果还有剩余数据要发送就会进入CLOSE_WAIT状态。

**TIME_WAIT** :

``` c++
//MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。
```



	* 又叫2MSL等待状态；
	* 如果客户端直接进入CLOSED状态，如果服务器没有收到最后一次ACK包会在超时后重新发送FIN包，此时因为客户端已经CLOSED，所以服务器就不会收到ACK而是收到RST。所以TIME_WAIT状态目的是防止最后一次握手数据没有到达对方而触发重传FIN准备的。
	* 在2MSL时间内，同一个socket不能再被使用，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。**也就是说在2MSL时间内，同一个socket不能再被任何人使用，这样是为了防止新的连接和旧的连接出现数据混淆**

#### 8.解释RTO,RTT和超时重传

超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：

- 发送的数据没能到达接收端，所以对方没有响应。
- 接收端接收到数据，但是ACK报文在返回过程中丢失。
- 接收端拒绝或丢弃数据。

RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔。

	* 通常每次重传RTO是前一次重传间隔的两倍，计量单位是RTT。例如：1RTT、2RTT、3RTT...;
	* 重传次数达到上限后停止重传；

RTT:数据从发送方到接收方之间的时间间隔，即数据在网络中一个往返用时。大小不稳定。

#### 9.流量控制原理？

	* 目的是接收方通过TCP头窗口字段告知发送方本方还可以接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。
 * TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗
   	* 发送窗：用来限制发送方可以发送数据的大小，其中发送方的发送窗口大小由接收方返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲大小。
      	* 接收窗：用来标记可以接收数据的大小；
* TCP是流数据，
  * 发送出去的数据流可以被分为以下四部分：已经发送且被确认部分|已经发送未被确认部分|未发送但是可以发送部分|未发送但是不可以发送 部分，其中发送窗=已发送未确认部分+未发但可发送部分。
  * 接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收部分。

![image-20200720200907744](C:\Users\miao\AppData\Roaming\Typora\typora-user-images\image-20200720200907744.png)

![preview](https://pic1.zhimg.com/9c21786770459afa47bfa2e4606cc454_r.jpg)

**发送端窗口的第一个字节序号一定是ACK中期望收到的下一个字节序号，因为也就是下一个即将发送的**

![image-20200720204226960](C:\Users\miao\AppData\Roaming\Typora\typora-user-images\image-20200720204226960.png)

``` c++
//发送窗口：收到ACK时就向前移动，窗口之前的全部都是已经ACK
//接收窗口：前部分全都收到时，才向前滑动，若收到不在接收窗口之内的不进行接收。
```

#### 10.拥塞控制原理

 * 拥塞控制目的是防止数据过多注入网络导致网络资源(路由器、交换机)过载。因为拥塞控制设计网络链路全局，所以属于全局控制。控制拥塞使用拥塞窗口。

 * TCP拥塞控制算法：

   	* 慢开始&拥塞控制：先试探网络拥塞程度再逐渐增大拥塞窗口。每次收到确认后拥塞窗口翻倍，直到达到阈值，这部分是慢开始过程。达到阈值后每次以一个MSS为单位增长拥塞窗口大小，当发生拥塞(超时未收到确认，3个)，将阈值减为原来一半，继续线性增加，这个过程为拥塞避免。

   ``` c++
   //如何确认拥塞发生：
   	(1)传输超时，或者TCP重传定时器溢出---慢启动和拥塞避免
   	(2)发送端收到3个重复的确认报文段，-----快速重传和快速回复。
   ```

   ​	* 最终拥塞窗口趋于稳定。

   ![img](https://img-blog.csdnimg.cn/20181128225158842.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2ODk2MjEz,size_16,color_FFFFFF,t_70)

#### 11.如何区分流量控制和拥塞控制？

	* 流量控制属于通信双方协商；拥塞控制涉及通信链路全局；
	* 流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方相应的TCP报文段中窗口值决定；拥塞控制的拥塞控制窗口由试探性发送一定数据量数据探查网络状况后而自适应调整；
	* 实际最终发送窗口 = min{流控发送窗口，拥塞窗口}。

#### 12.TCP如何提供可靠数据传输的？

	* 校验和
* 序列号
* 确认应答
* 超时重传
* 连接管理
* 流量控制
* 拥塞控制

#### 13.TCP socket交互流程？

 * 服务器：
    * 创建socket->int socket(int domain,int type,int protocol);
      	* domain：协议域，决定了socket的地址类型，IPv4为AF_INET。
      * type：指定socket类型，SOCK_STREAM为TCP连接。
      * protocol：指定协议。IPPROTO_TCP表示TCP协议，为0时自动选择type默认协议。
   * 绑定socket和端口号->int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
     * sockfd：socket返回的套接字描述符，类似于文件描述符fd。
     * addr：有个sockaddr类型数据的指针，指向的是被绑定结构变量。
     * addrlen：地址长度。

``` c++
 // IPv4的sockaddr地址结构
    struct sockaddr_in {
        sa_family_t sin_family;    // 协议类型，AF_INET
        in_port_t sin_port;    // 端口号
        struct in_addr sin_addr;    // IP地址
    };
    struct in_addr {
        uint32_t s_addr;
    }
```

   * 监听端口号 ->int listen(int sockfd, int backlog) 
     			* sockfd：要监听的sock描述字。
     * backlog：socket可以排队的最大连接数。
* 
* - 接收用户请求 -> int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
    - sockfd：服务器socket描述字。
    - addr：指向地址结构指针。
    - addrlen：协议地址长度。
    - 注：一旦accept某个客户机请求成功将返回一个全新的描述符用于标识具体客户的TCP连接。
  - 从socket中读取字符 -> ssize_t read(int fd, void *buf, size_t count);
    - fd：连接描述字。
    - buf：缓冲区buf。
    - count：缓冲区长度。
    - 注：大于0表示读取的字节数，返回0表示文件读取结束，小于0表示发生错误。
  - 关闭socket -> int close(int fd);
    - fd：accept返回的连接描述字，每个连接有一个，生命周期为连接周期。
    - 注：sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。
* 客户机：
  - 创建socket -> int socket(int domain, int type, int protocol);
  - 连接指定计算机 -> int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);
    - sockfd客户端的sock描述字。
    - addr：服务器的地址。
    - addrlen：socket地址长度。
  - 向socket写入信息 -> ssize_t write(int fd, const void *buf, size_t count);
    - fd、buf、count：同read中意义。
    - 大于0表示写了部分或全部数据，小于0表示出错。
  - 关闭oscket -> int close(int fd);
    - fd：同服务器端fd。

## 应用层

#### cookie和senssion

**一个 cookie 可以认为是一个「变量」，形如`name=value`，存储在浏览器；一个 session 可以理解为一种数据结构，多数情况是「映射」（键值对），存储在服务器上**

``` c++
//cookie理解为一个变量，存储在浏览器，用来标识用户；
//senssion理解为一种数据结构，存储在浏览器；
```



# 0825更新

#### 1.网段

网段：即广播域；

效果：相同网段可以通讯，不同网段不能通信。

``` c++
你看IP地址和子网掩码就知道了 复杂的就不说了 要想知道是不是一个网段 首先先看子网是不是一样 一般常用的C类IP地址 子网掩码都是255.255.255.0 就是说前3段表示网段如192.168.0.X 最后一位表示主机号 IP地址前3段一模一样就是一个网段 如 192.168.0.1和192.168.0.5是一个网段 最后一位从1到254都可以 都是一个网段 192.168.2.1和192.168.2.X也是一个网段 但192.168.0.X和192.168.2.X就不是一个网段 A类地址子网掩码是255.0.0.0 如 10.0.0.5和10.5.2.1是一个网段 只要第一段一样就是一个网段了 B类地址子网掩码是255.255.0.0 就是说前2段一样就是一个网段的 说的有点乱 不过应该能看懂了吧
```

子网掩码：将某个IP地址划分为网络地址和主机地址两部分。

#### 2.IP数据包格式

**IP数据报：**

IP版本号、首部长度、总长度、生存时间(TTL)、片偏移<每片在原数组中的位置，8字节代表一个偏移>

**IP地址编制方式：**

``` c++
//2级划分
IP地址：{<网络号><主机号>}

A、B、C、D、类地址；
//子网划分<3级划分>
    IP地址：{<网络号><子网号><主机号>}
//无分类CIDR
	128.14.35.7/20表示前20位为网络前缀
```

#### 3.ARP

如果主机的ARP高速缓存没有路由IP地址到MAC地址的转换，那么就要通过广播方式进行ARP解析；

#### 4.网际控制报文协议ICMP

建立在IP数据报之上，但是不属于高层协议；

ping

#### 5.虚拟地址VPN

#### 6.网络地址转换NET

#### 7.传输层

```c++
1.UDP和TCP
    UDP:无连接、最大可能的交付、没有拥塞控制，面向报文，支持一对一、一对多和多对多通信；
    TCP：面向连接、可靠交付、有流量控制，拥塞控制，面向字节流，点对点。
2.3次握手，4次挥手
        2MSL:MSL表示最大报文生存时间，指的是任何报文在网络上的存在的最长时间。
```

#### 8.DNS

``` c++
//根域名->顶级域名->二级域名
使用UDP/TCP进行传输，端口号为53，多数情况下使用UDP。
使用TCP传输情况：
    (1)返回的响应超过512字节；
    (2)区域传送(主域名服务器向辅助域名服务器传送的数据)
    //主域名服务器
///负责维护一个区域的所有域名信息，是特定的所有信息的权威信息源，数据可以修改。
//辅助域名服务器
//当主域名服务器出现故障、关闭或负载过重时，辅助域名服务器作为主域名服务器的备份提供域名解析服务。辅助域名服务器中的区域文件中的数据是从另外的一台主域名服务器中复制过来的，是不可以修改的。
```

#### 9.文件传输协议

``` c++
FTP使用TCP进行连接，他需要两个连接传输一个文件：
    //控制连接：服务器打开端口号21等待客户端连接，客户端主动建立连接后，使用这个链接将客户端的命令传送给服务器；
    //数据连接：用来传送一个文件数据。
FTP有主动模式和被动模式两种<相对服务器>
    //主动模式：服务端主动建立数据连接，客户端端口号随机；
    //被动模式：客户端主动建立连接，服务端端口随机。
    //主动模式要求客户端开发端口给服务器，需要配置客户端的防火墙；
    //被动模式需要服务器开发端口，但会导致服务端的安全性减弱。
```

#### 10.动态主机配置协议

``` c++
//DHCP
```

#### 11.电子邮件协议

``` c++
邮件协议包含发送协议和读取协议，发送协议常用SMTP，读取协议常用POP3
    //都是基于TCP传输
```

#### 12.HTTP方法

``` c++
1.GET:获取资源；
2.HEAD：获取报文首部，用于却URL有效性以及资源更新的日期和时间；
3.POST：传输实体主体；
4.PUT：上传文件；
5.DELEATE:删除文件。
```

#### 13.HTTP状态码

``` c++
403Forbidden:请求被拒绝
404 Not Found;
500:服务器正在执行请求中发送错误；
503：服务器暂时处于超负载或者正在停机维护中，现在无法处理请求。
```

#### 14.HTTPS

``` c++
1.对称密匙加密：加密解密同一把密匙；
2.非对称密匙加密：公有密匙用来加密，私有密匙用来解密
//https使用非对称密匙传输对称密匙，保证安全性；使用对称密匙进行通信保证传输效率；
 
```

#### 15.认证

``` c++
发送端先向权威机构提出公匙申请，权威机构CA对公有密匙做数字签名，然后放入公开密匙证书并绑定在一起。<证书是公开密匙的容器，包含接受者的公有密匙、公有密匙创建者的身份，创建日期和数字签名列表>
    
    //数字签名作用就是校验报文<一般是公匙>是否被更改；
    //如图：假设你想要成为一个受信任的网站或机构，只需要找你的上级机构去颁发证书给你，颁发时你将自己的公钥，host等信息发送到颁发机构，该机构会将自己的证书附上你的信息，并用自己的私钥签名，做成一张新的证书发给你；而这个上级机构他的证书又是同样的方法由CA颁发的。
https://blog.csdn.net/liweisnake/article/details/40074321?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase
  //那么，其他人怎么确认你的证书是合法的呢。首先你的证书会在https握手过程中被传递到浏览器，浏览器从你的证书中找到了颁发者，从颁发者的证书（如果你电脑上有的话）又找到了CA的证书（CA证书会在操作系统安装时就安装好，所以每个人电脑上都有根证书），使用CA证书中带的公钥来对颁发者证书做验签，一旦匹配，说明你电脑上的颁发者证书不是伪造的，同理，再用颁发者证书中的公钥去验证你的证书，以此证明你的证书不是伪造的。这样整个链状的验证，从而确保你的证书一定是直接或间接从CA签发的，这样浏览器地址栏会显示一个绿色的盾牌，表示你的网站能通过证书验证
```

//MD5加密算法：输入任意长度信息，经过处理输出位128位的信息(数字指纹)；不同的输入得到不同的结果；

MD5能够将原文转化为密文，但是不能将密文转化为原文。

#### 16.幂等性

``` c++
//幂等性：请求一次和连续请求多次的效果是一样的；
幂等性方法：GET、HEAD、PUT<put多次时，可以把上次的给覆盖掉>、DELETE
```

